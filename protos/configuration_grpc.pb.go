// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.3
// source: protos/configuration.proto

package protos

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	AuditService_LogEvent_FullMethodName           = "/configuration.AuditService/LogEvent"
	AuditService_GetAuditLog_FullMethodName        = "/configuration.AuditService/GetAuditLog"
	AuditService_ListAuditLogs_FullMethodName      = "/configuration.AuditService/ListAuditLogs"
	AuditService_CreateAuditReport_FullMethodName  = "/configuration.AuditService/CreateAuditReport"
	AuditService_GetAuditStatistics_FullMethodName = "/configuration.AuditService/GetAuditStatistics"
	AuditService_ExportAuditLogs_FullMethodName    = "/configuration.AuditService/ExportAuditLogs"
)

// AuditServiceClient is the client API for AuditService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AuditServiceClient interface {
	LogEvent(ctx context.Context, in *LogEventRequest, opts ...grpc.CallOption) (*LogEventResponse, error)
	GetAuditLog(ctx context.Context, in *GetAuditLogRequest, opts ...grpc.CallOption) (*GetAuditLogResponse, error)
	ListAuditLogs(ctx context.Context, in *ListAuditLogsRequest, opts ...grpc.CallOption) (*ListAuditLogsResponse, error)
	CreateAuditReport(ctx context.Context, in *CreateAuditReportRequest, opts ...grpc.CallOption) (*CreateAuditReportResponse, error)
	GetAuditStatistics(ctx context.Context, in *GetAuditStatisticsRequest, opts ...grpc.CallOption) (*GetAuditStatisticsResponse, error)
	ExportAuditLogs(ctx context.Context, in *ExportAuditLogsRequest, opts ...grpc.CallOption) (*ExportAuditLogsResponse, error)
}

type auditServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAuditServiceClient(cc grpc.ClientConnInterface) AuditServiceClient {
	return &auditServiceClient{cc}
}

func (c *auditServiceClient) LogEvent(ctx context.Context, in *LogEventRequest, opts ...grpc.CallOption) (*LogEventResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LogEventResponse)
	err := c.cc.Invoke(ctx, AuditService_LogEvent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *auditServiceClient) GetAuditLog(ctx context.Context, in *GetAuditLogRequest, opts ...grpc.CallOption) (*GetAuditLogResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAuditLogResponse)
	err := c.cc.Invoke(ctx, AuditService_GetAuditLog_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *auditServiceClient) ListAuditLogs(ctx context.Context, in *ListAuditLogsRequest, opts ...grpc.CallOption) (*ListAuditLogsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListAuditLogsResponse)
	err := c.cc.Invoke(ctx, AuditService_ListAuditLogs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *auditServiceClient) CreateAuditReport(ctx context.Context, in *CreateAuditReportRequest, opts ...grpc.CallOption) (*CreateAuditReportResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateAuditReportResponse)
	err := c.cc.Invoke(ctx, AuditService_CreateAuditReport_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *auditServiceClient) GetAuditStatistics(ctx context.Context, in *GetAuditStatisticsRequest, opts ...grpc.CallOption) (*GetAuditStatisticsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAuditStatisticsResponse)
	err := c.cc.Invoke(ctx, AuditService_GetAuditStatistics_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *auditServiceClient) ExportAuditLogs(ctx context.Context, in *ExportAuditLogsRequest, opts ...grpc.CallOption) (*ExportAuditLogsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExportAuditLogsResponse)
	err := c.cc.Invoke(ctx, AuditService_ExportAuditLogs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AuditServiceServer is the server API for AuditService service.
// All implementations must embed UnimplementedAuditServiceServer
// for forward compatibility.
type AuditServiceServer interface {
	LogEvent(context.Context, *LogEventRequest) (*LogEventResponse, error)
	GetAuditLog(context.Context, *GetAuditLogRequest) (*GetAuditLogResponse, error)
	ListAuditLogs(context.Context, *ListAuditLogsRequest) (*ListAuditLogsResponse, error)
	CreateAuditReport(context.Context, *CreateAuditReportRequest) (*CreateAuditReportResponse, error)
	GetAuditStatistics(context.Context, *GetAuditStatisticsRequest) (*GetAuditStatisticsResponse, error)
	ExportAuditLogs(context.Context, *ExportAuditLogsRequest) (*ExportAuditLogsResponse, error)
	mustEmbedUnimplementedAuditServiceServer()
}

// UnimplementedAuditServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAuditServiceServer struct{}

func (UnimplementedAuditServiceServer) LogEvent(context.Context, *LogEventRequest) (*LogEventResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LogEvent not implemented")
}
func (UnimplementedAuditServiceServer) GetAuditLog(context.Context, *GetAuditLogRequest) (*GetAuditLogResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAuditLog not implemented")
}
func (UnimplementedAuditServiceServer) ListAuditLogs(context.Context, *ListAuditLogsRequest) (*ListAuditLogsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAuditLogs not implemented")
}
func (UnimplementedAuditServiceServer) CreateAuditReport(context.Context, *CreateAuditReportRequest) (*CreateAuditReportResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAuditReport not implemented")
}
func (UnimplementedAuditServiceServer) GetAuditStatistics(context.Context, *GetAuditStatisticsRequest) (*GetAuditStatisticsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAuditStatistics not implemented")
}
func (UnimplementedAuditServiceServer) ExportAuditLogs(context.Context, *ExportAuditLogsRequest) (*ExportAuditLogsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExportAuditLogs not implemented")
}
func (UnimplementedAuditServiceServer) mustEmbedUnimplementedAuditServiceServer() {}
func (UnimplementedAuditServiceServer) testEmbeddedByValue()                      {}

// UnsafeAuditServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AuditServiceServer will
// result in compilation errors.
type UnsafeAuditServiceServer interface {
	mustEmbedUnimplementedAuditServiceServer()
}

func RegisterAuditServiceServer(s grpc.ServiceRegistrar, srv AuditServiceServer) {
	// If the following call pancis, it indicates UnimplementedAuditServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AuditService_ServiceDesc, srv)
}

func _AuditService_LogEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogEventRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuditServiceServer).LogEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuditService_LogEvent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuditServiceServer).LogEvent(ctx, req.(*LogEventRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuditService_GetAuditLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAuditLogRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuditServiceServer).GetAuditLog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuditService_GetAuditLog_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuditServiceServer).GetAuditLog(ctx, req.(*GetAuditLogRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuditService_ListAuditLogs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAuditLogsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuditServiceServer).ListAuditLogs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuditService_ListAuditLogs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuditServiceServer).ListAuditLogs(ctx, req.(*ListAuditLogsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuditService_CreateAuditReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateAuditReportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuditServiceServer).CreateAuditReport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuditService_CreateAuditReport_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuditServiceServer).CreateAuditReport(ctx, req.(*CreateAuditReportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuditService_GetAuditStatistics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAuditStatisticsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuditServiceServer).GetAuditStatistics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuditService_GetAuditStatistics_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuditServiceServer).GetAuditStatistics(ctx, req.(*GetAuditStatisticsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuditService_ExportAuditLogs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExportAuditLogsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuditServiceServer).ExportAuditLogs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuditService_ExportAuditLogs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuditServiceServer).ExportAuditLogs(ctx, req.(*ExportAuditLogsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AuditService_ServiceDesc is the grpc.ServiceDesc for AuditService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AuditService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "configuration.AuditService",
	HandlerType: (*AuditServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "LogEvent",
			Handler:    _AuditService_LogEvent_Handler,
		},
		{
			MethodName: "GetAuditLog",
			Handler:    _AuditService_GetAuditLog_Handler,
		},
		{
			MethodName: "ListAuditLogs",
			Handler:    _AuditService_ListAuditLogs_Handler,
		},
		{
			MethodName: "CreateAuditReport",
			Handler:    _AuditService_CreateAuditReport_Handler,
		},
		{
			MethodName: "GetAuditStatistics",
			Handler:    _AuditService_GetAuditStatistics_Handler,
		},
		{
			MethodName: "ExportAuditLogs",
			Handler:    _AuditService_ExportAuditLogs_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "protos/configuration.proto",
}

const (
	ConfigurationService_GetConfig_FullMethodName        = "/configuration.ConfigurationService/GetConfig"
	ConfigurationService_UpdateConfig_FullMethodName     = "/configuration.ConfigurationService/UpdateConfig"
	ConfigurationService_ListConfigs_FullMethodName      = "/configuration.ConfigurationService/ListConfigs"
	ConfigurationService_ResetConfig_FullMethodName      = "/configuration.ConfigurationService/ResetConfig"
	ConfigurationService_GetConfigHistory_FullMethodName = "/configuration.ConfigurationService/GetConfigHistory"
	ConfigurationService_ValidateConfig_FullMethodName   = "/configuration.ConfigurationService/ValidateConfig"
	ConfigurationService_BackupConfigs_FullMethodName    = "/configuration.ConfigurationService/BackupConfigs"
	ConfigurationService_RestoreConfigs_FullMethodName   = "/configuration.ConfigurationService/RestoreConfigs"
)

// ConfigurationServiceClient is the client API for ConfigurationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ConfigurationServiceClient interface {
	GetConfig(ctx context.Context, in *GetConfigRequest, opts ...grpc.CallOption) (*GetConfigResponse, error)
	UpdateConfig(ctx context.Context, in *UpdateConfigRequest, opts ...grpc.CallOption) (*UpdateConfigResponse, error)
	ListConfigs(ctx context.Context, in *ListConfigsRequest, opts ...grpc.CallOption) (*ListConfigsResponse, error)
	ResetConfig(ctx context.Context, in *ResetConfigRequest, opts ...grpc.CallOption) (*ResetConfigResponse, error)
	GetConfigHistory(ctx context.Context, in *GetConfigHistoryRequest, opts ...grpc.CallOption) (*GetConfigHistoryResponse, error)
	ValidateConfig(ctx context.Context, in *ValidateConfigRequest, opts ...grpc.CallOption) (*ValidateConfigResponse, error)
	BackupConfigs(ctx context.Context, in *BackupConfigsRequest, opts ...grpc.CallOption) (*BackupConfigsResponse, error)
	RestoreConfigs(ctx context.Context, in *RestoreConfigsRequest, opts ...grpc.CallOption) (*RestoreConfigsResponse, error)
}

type configurationServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewConfigurationServiceClient(cc grpc.ClientConnInterface) ConfigurationServiceClient {
	return &configurationServiceClient{cc}
}

func (c *configurationServiceClient) GetConfig(ctx context.Context, in *GetConfigRequest, opts ...grpc.CallOption) (*GetConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetConfigResponse)
	err := c.cc.Invoke(ctx, ConfigurationService_GetConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *configurationServiceClient) UpdateConfig(ctx context.Context, in *UpdateConfigRequest, opts ...grpc.CallOption) (*UpdateConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateConfigResponse)
	err := c.cc.Invoke(ctx, ConfigurationService_UpdateConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *configurationServiceClient) ListConfigs(ctx context.Context, in *ListConfigsRequest, opts ...grpc.CallOption) (*ListConfigsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListConfigsResponse)
	err := c.cc.Invoke(ctx, ConfigurationService_ListConfigs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *configurationServiceClient) ResetConfig(ctx context.Context, in *ResetConfigRequest, opts ...grpc.CallOption) (*ResetConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResetConfigResponse)
	err := c.cc.Invoke(ctx, ConfigurationService_ResetConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *configurationServiceClient) GetConfigHistory(ctx context.Context, in *GetConfigHistoryRequest, opts ...grpc.CallOption) (*GetConfigHistoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetConfigHistoryResponse)
	err := c.cc.Invoke(ctx, ConfigurationService_GetConfigHistory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *configurationServiceClient) ValidateConfig(ctx context.Context, in *ValidateConfigRequest, opts ...grpc.CallOption) (*ValidateConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ValidateConfigResponse)
	err := c.cc.Invoke(ctx, ConfigurationService_ValidateConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *configurationServiceClient) BackupConfigs(ctx context.Context, in *BackupConfigsRequest, opts ...grpc.CallOption) (*BackupConfigsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BackupConfigsResponse)
	err := c.cc.Invoke(ctx, ConfigurationService_BackupConfigs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *configurationServiceClient) RestoreConfigs(ctx context.Context, in *RestoreConfigsRequest, opts ...grpc.CallOption) (*RestoreConfigsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RestoreConfigsResponse)
	err := c.cc.Invoke(ctx, ConfigurationService_RestoreConfigs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ConfigurationServiceServer is the server API for ConfigurationService service.
// All implementations must embed UnimplementedConfigurationServiceServer
// for forward compatibility.
type ConfigurationServiceServer interface {
	GetConfig(context.Context, *GetConfigRequest) (*GetConfigResponse, error)
	UpdateConfig(context.Context, *UpdateConfigRequest) (*UpdateConfigResponse, error)
	ListConfigs(context.Context, *ListConfigsRequest) (*ListConfigsResponse, error)
	ResetConfig(context.Context, *ResetConfigRequest) (*ResetConfigResponse, error)
	GetConfigHistory(context.Context, *GetConfigHistoryRequest) (*GetConfigHistoryResponse, error)
	ValidateConfig(context.Context, *ValidateConfigRequest) (*ValidateConfigResponse, error)
	BackupConfigs(context.Context, *BackupConfigsRequest) (*BackupConfigsResponse, error)
	RestoreConfigs(context.Context, *RestoreConfigsRequest) (*RestoreConfigsResponse, error)
	mustEmbedUnimplementedConfigurationServiceServer()
}

// UnimplementedConfigurationServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedConfigurationServiceServer struct{}

func (UnimplementedConfigurationServiceServer) GetConfig(context.Context, *GetConfigRequest) (*GetConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConfig not implemented")
}
func (UnimplementedConfigurationServiceServer) UpdateConfig(context.Context, *UpdateConfigRequest) (*UpdateConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateConfig not implemented")
}
func (UnimplementedConfigurationServiceServer) ListConfigs(context.Context, *ListConfigsRequest) (*ListConfigsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListConfigs not implemented")
}
func (UnimplementedConfigurationServiceServer) ResetConfig(context.Context, *ResetConfigRequest) (*ResetConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetConfig not implemented")
}
func (UnimplementedConfigurationServiceServer) GetConfigHistory(context.Context, *GetConfigHistoryRequest) (*GetConfigHistoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConfigHistory not implemented")
}
func (UnimplementedConfigurationServiceServer) ValidateConfig(context.Context, *ValidateConfigRequest) (*ValidateConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateConfig not implemented")
}
func (UnimplementedConfigurationServiceServer) BackupConfigs(context.Context, *BackupConfigsRequest) (*BackupConfigsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BackupConfigs not implemented")
}
func (UnimplementedConfigurationServiceServer) RestoreConfigs(context.Context, *RestoreConfigsRequest) (*RestoreConfigsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RestoreConfigs not implemented")
}
func (UnimplementedConfigurationServiceServer) mustEmbedUnimplementedConfigurationServiceServer() {}
func (UnimplementedConfigurationServiceServer) testEmbeddedByValue()                              {}

// UnsafeConfigurationServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ConfigurationServiceServer will
// result in compilation errors.
type UnsafeConfigurationServiceServer interface {
	mustEmbedUnimplementedConfigurationServiceServer()
}

func RegisterConfigurationServiceServer(s grpc.ServiceRegistrar, srv ConfigurationServiceServer) {
	// If the following call pancis, it indicates UnimplementedConfigurationServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ConfigurationService_ServiceDesc, srv)
}

func _ConfigurationService_GetConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigurationServiceServer).GetConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConfigurationService_GetConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigurationServiceServer).GetConfig(ctx, req.(*GetConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConfigurationService_UpdateConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigurationServiceServer).UpdateConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConfigurationService_UpdateConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigurationServiceServer).UpdateConfig(ctx, req.(*UpdateConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConfigurationService_ListConfigs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListConfigsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigurationServiceServer).ListConfigs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConfigurationService_ListConfigs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigurationServiceServer).ListConfigs(ctx, req.(*ListConfigsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConfigurationService_ResetConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResetConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigurationServiceServer).ResetConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConfigurationService_ResetConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigurationServiceServer).ResetConfig(ctx, req.(*ResetConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConfigurationService_GetConfigHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetConfigHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigurationServiceServer).GetConfigHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConfigurationService_GetConfigHistory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigurationServiceServer).GetConfigHistory(ctx, req.(*GetConfigHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConfigurationService_ValidateConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigurationServiceServer).ValidateConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConfigurationService_ValidateConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigurationServiceServer).ValidateConfig(ctx, req.(*ValidateConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConfigurationService_BackupConfigs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BackupConfigsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigurationServiceServer).BackupConfigs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConfigurationService_BackupConfigs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigurationServiceServer).BackupConfigs(ctx, req.(*BackupConfigsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConfigurationService_RestoreConfigs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RestoreConfigsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigurationServiceServer).RestoreConfigs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConfigurationService_RestoreConfigs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigurationServiceServer).RestoreConfigs(ctx, req.(*RestoreConfigsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ConfigurationService_ServiceDesc is the grpc.ServiceDesc for ConfigurationService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ConfigurationService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "configuration.ConfigurationService",
	HandlerType: (*ConfigurationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetConfig",
			Handler:    _ConfigurationService_GetConfig_Handler,
		},
		{
			MethodName: "UpdateConfig",
			Handler:    _ConfigurationService_UpdateConfig_Handler,
		},
		{
			MethodName: "ListConfigs",
			Handler:    _ConfigurationService_ListConfigs_Handler,
		},
		{
			MethodName: "ResetConfig",
			Handler:    _ConfigurationService_ResetConfig_Handler,
		},
		{
			MethodName: "GetConfigHistory",
			Handler:    _ConfigurationService_GetConfigHistory_Handler,
		},
		{
			MethodName: "ValidateConfig",
			Handler:    _ConfigurationService_ValidateConfig_Handler,
		},
		{
			MethodName: "BackupConfigs",
			Handler:    _ConfigurationService_BackupConfigs_Handler,
		},
		{
			MethodName: "RestoreConfigs",
			Handler:    _ConfigurationService_RestoreConfigs_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "protos/configuration.proto",
}

const (
	WebhookService_CreateWebhook_FullMethodName        = "/configuration.WebhookService/CreateWebhook"
	WebhookService_GetWebhook_FullMethodName           = "/configuration.WebhookService/GetWebhook"
	WebhookService_UpdateWebhook_FullMethodName        = "/configuration.WebhookService/UpdateWebhook"
	WebhookService_ListWebhooks_FullMethodName         = "/configuration.WebhookService/ListWebhooks"
	WebhookService_DeleteWebhook_FullMethodName        = "/configuration.WebhookService/DeleteWebhook"
	WebhookService_TestWebhook_FullMethodName          = "/configuration.WebhookService/TestWebhook"
	WebhookService_GetWebhookDeliveries_FullMethodName = "/configuration.WebhookService/GetWebhookDeliveries"
	WebhookService_ResendWebhook_FullMethodName        = "/configuration.WebhookService/ResendWebhook"
	WebhookService_GetWebhookStats_FullMethodName      = "/configuration.WebhookService/GetWebhookStats"
	WebhookService_PauseWebhook_FullMethodName         = "/configuration.WebhookService/PauseWebhook"
	WebhookService_ResumeWebhook_FullMethodName        = "/configuration.WebhookService/ResumeWebhook"
)

// WebhookServiceClient is the client API for WebhookService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type WebhookServiceClient interface {
	CreateWebhook(ctx context.Context, in *CreateWebhookRequest, opts ...grpc.CallOption) (*CreateWebhookResponse, error)
	GetWebhook(ctx context.Context, in *GetWebhookRequest, opts ...grpc.CallOption) (*GetWebhookResponse, error)
	UpdateWebhook(ctx context.Context, in *UpdateWebhookRequest, opts ...grpc.CallOption) (*UpdateWebhookResponse, error)
	ListWebhooks(ctx context.Context, in *ListWebhooksRequest, opts ...grpc.CallOption) (*ListWebhooksResponse, error)
	DeleteWebhook(ctx context.Context, in *DeleteWebhookRequest, opts ...grpc.CallOption) (*DeleteWebhookResponse, error)
	TestWebhook(ctx context.Context, in *TestWebhookRequest, opts ...grpc.CallOption) (*TestWebhookResponse, error)
	GetWebhookDeliveries(ctx context.Context, in *GetWebhookDeliveriesRequest, opts ...grpc.CallOption) (*GetWebhookDeliveriesResponse, error)
	ResendWebhook(ctx context.Context, in *ResendWebhookRequest, opts ...grpc.CallOption) (*ResendWebhookResponse, error)
	GetWebhookStats(ctx context.Context, in *GetWebhookStatsRequest, opts ...grpc.CallOption) (*GetWebhookStatsResponse, error)
	PauseWebhook(ctx context.Context, in *PauseWebhookRequest, opts ...grpc.CallOption) (*PauseWebhookResponse, error)
	ResumeWebhook(ctx context.Context, in *ResumeWebhookRequest, opts ...grpc.CallOption) (*ResumeWebhookResponse, error)
}

type webhookServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewWebhookServiceClient(cc grpc.ClientConnInterface) WebhookServiceClient {
	return &webhookServiceClient{cc}
}

func (c *webhookServiceClient) CreateWebhook(ctx context.Context, in *CreateWebhookRequest, opts ...grpc.CallOption) (*CreateWebhookResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateWebhookResponse)
	err := c.cc.Invoke(ctx, WebhookService_CreateWebhook_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webhookServiceClient) GetWebhook(ctx context.Context, in *GetWebhookRequest, opts ...grpc.CallOption) (*GetWebhookResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetWebhookResponse)
	err := c.cc.Invoke(ctx, WebhookService_GetWebhook_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webhookServiceClient) UpdateWebhook(ctx context.Context, in *UpdateWebhookRequest, opts ...grpc.CallOption) (*UpdateWebhookResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateWebhookResponse)
	err := c.cc.Invoke(ctx, WebhookService_UpdateWebhook_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webhookServiceClient) ListWebhooks(ctx context.Context, in *ListWebhooksRequest, opts ...grpc.CallOption) (*ListWebhooksResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListWebhooksResponse)
	err := c.cc.Invoke(ctx, WebhookService_ListWebhooks_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webhookServiceClient) DeleteWebhook(ctx context.Context, in *DeleteWebhookRequest, opts ...grpc.CallOption) (*DeleteWebhookResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteWebhookResponse)
	err := c.cc.Invoke(ctx, WebhookService_DeleteWebhook_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webhookServiceClient) TestWebhook(ctx context.Context, in *TestWebhookRequest, opts ...grpc.CallOption) (*TestWebhookResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TestWebhookResponse)
	err := c.cc.Invoke(ctx, WebhookService_TestWebhook_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webhookServiceClient) GetWebhookDeliveries(ctx context.Context, in *GetWebhookDeliveriesRequest, opts ...grpc.CallOption) (*GetWebhookDeliveriesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetWebhookDeliveriesResponse)
	err := c.cc.Invoke(ctx, WebhookService_GetWebhookDeliveries_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webhookServiceClient) ResendWebhook(ctx context.Context, in *ResendWebhookRequest, opts ...grpc.CallOption) (*ResendWebhookResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResendWebhookResponse)
	err := c.cc.Invoke(ctx, WebhookService_ResendWebhook_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webhookServiceClient) GetWebhookStats(ctx context.Context, in *GetWebhookStatsRequest, opts ...grpc.CallOption) (*GetWebhookStatsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetWebhookStatsResponse)
	err := c.cc.Invoke(ctx, WebhookService_GetWebhookStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webhookServiceClient) PauseWebhook(ctx context.Context, in *PauseWebhookRequest, opts ...grpc.CallOption) (*PauseWebhookResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PauseWebhookResponse)
	err := c.cc.Invoke(ctx, WebhookService_PauseWebhook_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webhookServiceClient) ResumeWebhook(ctx context.Context, in *ResumeWebhookRequest, opts ...grpc.CallOption) (*ResumeWebhookResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResumeWebhookResponse)
	err := c.cc.Invoke(ctx, WebhookService_ResumeWebhook_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WebhookServiceServer is the server API for WebhookService service.
// All implementations must embed UnimplementedWebhookServiceServer
// for forward compatibility.
type WebhookServiceServer interface {
	CreateWebhook(context.Context, *CreateWebhookRequest) (*CreateWebhookResponse, error)
	GetWebhook(context.Context, *GetWebhookRequest) (*GetWebhookResponse, error)
	UpdateWebhook(context.Context, *UpdateWebhookRequest) (*UpdateWebhookResponse, error)
	ListWebhooks(context.Context, *ListWebhooksRequest) (*ListWebhooksResponse, error)
	DeleteWebhook(context.Context, *DeleteWebhookRequest) (*DeleteWebhookResponse, error)
	TestWebhook(context.Context, *TestWebhookRequest) (*TestWebhookResponse, error)
	GetWebhookDeliveries(context.Context, *GetWebhookDeliveriesRequest) (*GetWebhookDeliveriesResponse, error)
	ResendWebhook(context.Context, *ResendWebhookRequest) (*ResendWebhookResponse, error)
	GetWebhookStats(context.Context, *GetWebhookStatsRequest) (*GetWebhookStatsResponse, error)
	PauseWebhook(context.Context, *PauseWebhookRequest) (*PauseWebhookResponse, error)
	ResumeWebhook(context.Context, *ResumeWebhookRequest) (*ResumeWebhookResponse, error)
	mustEmbedUnimplementedWebhookServiceServer()
}

// UnimplementedWebhookServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedWebhookServiceServer struct{}

func (UnimplementedWebhookServiceServer) CreateWebhook(context.Context, *CreateWebhookRequest) (*CreateWebhookResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateWebhook not implemented")
}
func (UnimplementedWebhookServiceServer) GetWebhook(context.Context, *GetWebhookRequest) (*GetWebhookResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWebhook not implemented")
}
func (UnimplementedWebhookServiceServer) UpdateWebhook(context.Context, *UpdateWebhookRequest) (*UpdateWebhookResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateWebhook not implemented")
}
func (UnimplementedWebhookServiceServer) ListWebhooks(context.Context, *ListWebhooksRequest) (*ListWebhooksResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListWebhooks not implemented")
}
func (UnimplementedWebhookServiceServer) DeleteWebhook(context.Context, *DeleteWebhookRequest) (*DeleteWebhookResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteWebhook not implemented")
}
func (UnimplementedWebhookServiceServer) TestWebhook(context.Context, *TestWebhookRequest) (*TestWebhookResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TestWebhook not implemented")
}
func (UnimplementedWebhookServiceServer) GetWebhookDeliveries(context.Context, *GetWebhookDeliveriesRequest) (*GetWebhookDeliveriesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWebhookDeliveries not implemented")
}
func (UnimplementedWebhookServiceServer) ResendWebhook(context.Context, *ResendWebhookRequest) (*ResendWebhookResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResendWebhook not implemented")
}
func (UnimplementedWebhookServiceServer) GetWebhookStats(context.Context, *GetWebhookStatsRequest) (*GetWebhookStatsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWebhookStats not implemented")
}
func (UnimplementedWebhookServiceServer) PauseWebhook(context.Context, *PauseWebhookRequest) (*PauseWebhookResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PauseWebhook not implemented")
}
func (UnimplementedWebhookServiceServer) ResumeWebhook(context.Context, *ResumeWebhookRequest) (*ResumeWebhookResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResumeWebhook not implemented")
}
func (UnimplementedWebhookServiceServer) mustEmbedUnimplementedWebhookServiceServer() {}
func (UnimplementedWebhookServiceServer) testEmbeddedByValue()                        {}

// UnsafeWebhookServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to WebhookServiceServer will
// result in compilation errors.
type UnsafeWebhookServiceServer interface {
	mustEmbedUnimplementedWebhookServiceServer()
}

func RegisterWebhookServiceServer(s grpc.ServiceRegistrar, srv WebhookServiceServer) {
	// If the following call pancis, it indicates UnimplementedWebhookServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&WebhookService_ServiceDesc, srv)
}

func _WebhookService_CreateWebhook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateWebhookRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebhookServiceServer).CreateWebhook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WebhookService_CreateWebhook_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebhookServiceServer).CreateWebhook(ctx, req.(*CreateWebhookRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WebhookService_GetWebhook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetWebhookRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebhookServiceServer).GetWebhook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WebhookService_GetWebhook_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebhookServiceServer).GetWebhook(ctx, req.(*GetWebhookRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WebhookService_UpdateWebhook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateWebhookRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebhookServiceServer).UpdateWebhook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WebhookService_UpdateWebhook_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebhookServiceServer).UpdateWebhook(ctx, req.(*UpdateWebhookRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WebhookService_ListWebhooks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListWebhooksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebhookServiceServer).ListWebhooks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WebhookService_ListWebhooks_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebhookServiceServer).ListWebhooks(ctx, req.(*ListWebhooksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WebhookService_DeleteWebhook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteWebhookRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebhookServiceServer).DeleteWebhook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WebhookService_DeleteWebhook_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebhookServiceServer).DeleteWebhook(ctx, req.(*DeleteWebhookRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WebhookService_TestWebhook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestWebhookRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebhookServiceServer).TestWebhook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WebhookService_TestWebhook_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebhookServiceServer).TestWebhook(ctx, req.(*TestWebhookRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WebhookService_GetWebhookDeliveries_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetWebhookDeliveriesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebhookServiceServer).GetWebhookDeliveries(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WebhookService_GetWebhookDeliveries_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebhookServiceServer).GetWebhookDeliveries(ctx, req.(*GetWebhookDeliveriesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WebhookService_ResendWebhook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResendWebhookRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebhookServiceServer).ResendWebhook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WebhookService_ResendWebhook_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebhookServiceServer).ResendWebhook(ctx, req.(*ResendWebhookRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WebhookService_GetWebhookStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetWebhookStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebhookServiceServer).GetWebhookStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WebhookService_GetWebhookStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebhookServiceServer).GetWebhookStats(ctx, req.(*GetWebhookStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WebhookService_PauseWebhook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PauseWebhookRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebhookServiceServer).PauseWebhook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WebhookService_PauseWebhook_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebhookServiceServer).PauseWebhook(ctx, req.(*PauseWebhookRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WebhookService_ResumeWebhook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResumeWebhookRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebhookServiceServer).ResumeWebhook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WebhookService_ResumeWebhook_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebhookServiceServer).ResumeWebhook(ctx, req.(*ResumeWebhookRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// WebhookService_ServiceDesc is the grpc.ServiceDesc for WebhookService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var WebhookService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "configuration.WebhookService",
	HandlerType: (*WebhookServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateWebhook",
			Handler:    _WebhookService_CreateWebhook_Handler,
		},
		{
			MethodName: "GetWebhook",
			Handler:    _WebhookService_GetWebhook_Handler,
		},
		{
			MethodName: "UpdateWebhook",
			Handler:    _WebhookService_UpdateWebhook_Handler,
		},
		{
			MethodName: "ListWebhooks",
			Handler:    _WebhookService_ListWebhooks_Handler,
		},
		{
			MethodName: "DeleteWebhook",
			Handler:    _WebhookService_DeleteWebhook_Handler,
		},
		{
			MethodName: "TestWebhook",
			Handler:    _WebhookService_TestWebhook_Handler,
		},
		{
			MethodName: "GetWebhookDeliveries",
			Handler:    _WebhookService_GetWebhookDeliveries_Handler,
		},
		{
			MethodName: "ResendWebhook",
			Handler:    _WebhookService_ResendWebhook_Handler,
		},
		{
			MethodName: "GetWebhookStats",
			Handler:    _WebhookService_GetWebhookStats_Handler,
		},
		{
			MethodName: "PauseWebhook",
			Handler:    _WebhookService_PauseWebhook_Handler,
		},
		{
			MethodName: "ResumeWebhook",
			Handler:    _WebhookService_ResumeWebhook_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "protos/configuration.proto",
}

const (
	FileStorageService_UploadFile_FullMethodName      = "/configuration.FileStorageService/UploadFile"
	FileStorageService_GetFile_FullMethodName         = "/configuration.FileStorageService/GetFile"
	FileStorageService_DeleteFile_FullMethodName      = "/configuration.FileStorageService/DeleteFile"
	FileStorageService_ListFiles_FullMethodName       = "/configuration.FileStorageService/ListFiles"
	FileStorageService_GetUploadUrl_FullMethodName    = "/configuration.FileStorageService/GetUploadUrl"
	FileStorageService_GetDownloadUrl_FullMethodName  = "/configuration.FileStorageService/GetDownloadUrl"
	FileStorageService_MoveFile_FullMethodName        = "/configuration.FileStorageService/MoveFile"
	FileStorageService_CopyFile_FullMethodName        = "/configuration.FileStorageService/CopyFile"
	FileStorageService_GetStorageQuota_FullMethodName = "/configuration.FileStorageService/GetStorageQuota"
)

// FileStorageServiceClient is the client API for FileStorageService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FileStorageServiceClient interface {
	UploadFile(ctx context.Context, in *UploadFileRequest, opts ...grpc.CallOption) (*UploadFileResponse, error)
	GetFile(ctx context.Context, in *GetFileRequest, opts ...grpc.CallOption) (*GetFileResponse, error)
	DeleteFile(ctx context.Context, in *DeleteFileRequest, opts ...grpc.CallOption) (*DeleteFileResponse, error)
	ListFiles(ctx context.Context, in *ListFilesRequest, opts ...grpc.CallOption) (*ListFilesResponse, error)
	GetUploadUrl(ctx context.Context, in *GetUploadUrlRequest, opts ...grpc.CallOption) (*GetUploadUrlResponse, error)
	GetDownloadUrl(ctx context.Context, in *GetDownloadUrlRequest, opts ...grpc.CallOption) (*GetDownloadUrlResponse, error)
	MoveFile(ctx context.Context, in *MoveFileRequest, opts ...grpc.CallOption) (*MoveFileResponse, error)
	CopyFile(ctx context.Context, in *CopyFileRequest, opts ...grpc.CallOption) (*CopyFileResponse, error)
	GetStorageQuota(ctx context.Context, in *GetStorageQuotaRequest, opts ...grpc.CallOption) (*GetStorageQuotaResponse, error)
}

type fileStorageServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewFileStorageServiceClient(cc grpc.ClientConnInterface) FileStorageServiceClient {
	return &fileStorageServiceClient{cc}
}

func (c *fileStorageServiceClient) UploadFile(ctx context.Context, in *UploadFileRequest, opts ...grpc.CallOption) (*UploadFileResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UploadFileResponse)
	err := c.cc.Invoke(ctx, FileStorageService_UploadFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileStorageServiceClient) GetFile(ctx context.Context, in *GetFileRequest, opts ...grpc.CallOption) (*GetFileResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetFileResponse)
	err := c.cc.Invoke(ctx, FileStorageService_GetFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileStorageServiceClient) DeleteFile(ctx context.Context, in *DeleteFileRequest, opts ...grpc.CallOption) (*DeleteFileResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteFileResponse)
	err := c.cc.Invoke(ctx, FileStorageService_DeleteFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileStorageServiceClient) ListFiles(ctx context.Context, in *ListFilesRequest, opts ...grpc.CallOption) (*ListFilesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListFilesResponse)
	err := c.cc.Invoke(ctx, FileStorageService_ListFiles_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileStorageServiceClient) GetUploadUrl(ctx context.Context, in *GetUploadUrlRequest, opts ...grpc.CallOption) (*GetUploadUrlResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetUploadUrlResponse)
	err := c.cc.Invoke(ctx, FileStorageService_GetUploadUrl_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileStorageServiceClient) GetDownloadUrl(ctx context.Context, in *GetDownloadUrlRequest, opts ...grpc.CallOption) (*GetDownloadUrlResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetDownloadUrlResponse)
	err := c.cc.Invoke(ctx, FileStorageService_GetDownloadUrl_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileStorageServiceClient) MoveFile(ctx context.Context, in *MoveFileRequest, opts ...grpc.CallOption) (*MoveFileResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MoveFileResponse)
	err := c.cc.Invoke(ctx, FileStorageService_MoveFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileStorageServiceClient) CopyFile(ctx context.Context, in *CopyFileRequest, opts ...grpc.CallOption) (*CopyFileResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CopyFileResponse)
	err := c.cc.Invoke(ctx, FileStorageService_CopyFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileStorageServiceClient) GetStorageQuota(ctx context.Context, in *GetStorageQuotaRequest, opts ...grpc.CallOption) (*GetStorageQuotaResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetStorageQuotaResponse)
	err := c.cc.Invoke(ctx, FileStorageService_GetStorageQuota_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FileStorageServiceServer is the server API for FileStorageService service.
// All implementations must embed UnimplementedFileStorageServiceServer
// for forward compatibility.
type FileStorageServiceServer interface {
	UploadFile(context.Context, *UploadFileRequest) (*UploadFileResponse, error)
	GetFile(context.Context, *GetFileRequest) (*GetFileResponse, error)
	DeleteFile(context.Context, *DeleteFileRequest) (*DeleteFileResponse, error)
	ListFiles(context.Context, *ListFilesRequest) (*ListFilesResponse, error)
	GetUploadUrl(context.Context, *GetUploadUrlRequest) (*GetUploadUrlResponse, error)
	GetDownloadUrl(context.Context, *GetDownloadUrlRequest) (*GetDownloadUrlResponse, error)
	MoveFile(context.Context, *MoveFileRequest) (*MoveFileResponse, error)
	CopyFile(context.Context, *CopyFileRequest) (*CopyFileResponse, error)
	GetStorageQuota(context.Context, *GetStorageQuotaRequest) (*GetStorageQuotaResponse, error)
	mustEmbedUnimplementedFileStorageServiceServer()
}

// UnimplementedFileStorageServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedFileStorageServiceServer struct{}

func (UnimplementedFileStorageServiceServer) UploadFile(context.Context, *UploadFileRequest) (*UploadFileResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UploadFile not implemented")
}
func (UnimplementedFileStorageServiceServer) GetFile(context.Context, *GetFileRequest) (*GetFileResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFile not implemented")
}
func (UnimplementedFileStorageServiceServer) DeleteFile(context.Context, *DeleteFileRequest) (*DeleteFileResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteFile not implemented")
}
func (UnimplementedFileStorageServiceServer) ListFiles(context.Context, *ListFilesRequest) (*ListFilesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListFiles not implemented")
}
func (UnimplementedFileStorageServiceServer) GetUploadUrl(context.Context, *GetUploadUrlRequest) (*GetUploadUrlResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUploadUrl not implemented")
}
func (UnimplementedFileStorageServiceServer) GetDownloadUrl(context.Context, *GetDownloadUrlRequest) (*GetDownloadUrlResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDownloadUrl not implemented")
}
func (UnimplementedFileStorageServiceServer) MoveFile(context.Context, *MoveFileRequest) (*MoveFileResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MoveFile not implemented")
}
func (UnimplementedFileStorageServiceServer) CopyFile(context.Context, *CopyFileRequest) (*CopyFileResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CopyFile not implemented")
}
func (UnimplementedFileStorageServiceServer) GetStorageQuota(context.Context, *GetStorageQuotaRequest) (*GetStorageQuotaResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStorageQuota not implemented")
}
func (UnimplementedFileStorageServiceServer) mustEmbedUnimplementedFileStorageServiceServer() {}
func (UnimplementedFileStorageServiceServer) testEmbeddedByValue()                            {}

// UnsafeFileStorageServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FileStorageServiceServer will
// result in compilation errors.
type UnsafeFileStorageServiceServer interface {
	mustEmbedUnimplementedFileStorageServiceServer()
}

func RegisterFileStorageServiceServer(s grpc.ServiceRegistrar, srv FileStorageServiceServer) {
	// If the following call pancis, it indicates UnimplementedFileStorageServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&FileStorageService_ServiceDesc, srv)
}

func _FileStorageService_UploadFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UploadFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileStorageServiceServer).UploadFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FileStorageService_UploadFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileStorageServiceServer).UploadFile(ctx, req.(*UploadFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileStorageService_GetFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileStorageServiceServer).GetFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FileStorageService_GetFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileStorageServiceServer).GetFile(ctx, req.(*GetFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileStorageService_DeleteFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileStorageServiceServer).DeleteFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FileStorageService_DeleteFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileStorageServiceServer).DeleteFile(ctx, req.(*DeleteFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileStorageService_ListFiles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListFilesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileStorageServiceServer).ListFiles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FileStorageService_ListFiles_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileStorageServiceServer).ListFiles(ctx, req.(*ListFilesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileStorageService_GetUploadUrl_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUploadUrlRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileStorageServiceServer).GetUploadUrl(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FileStorageService_GetUploadUrl_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileStorageServiceServer).GetUploadUrl(ctx, req.(*GetUploadUrlRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileStorageService_GetDownloadUrl_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDownloadUrlRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileStorageServiceServer).GetDownloadUrl(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FileStorageService_GetDownloadUrl_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileStorageServiceServer).GetDownloadUrl(ctx, req.(*GetDownloadUrlRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileStorageService_MoveFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MoveFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileStorageServiceServer).MoveFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FileStorageService_MoveFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileStorageServiceServer).MoveFile(ctx, req.(*MoveFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileStorageService_CopyFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CopyFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileStorageServiceServer).CopyFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FileStorageService_CopyFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileStorageServiceServer).CopyFile(ctx, req.(*CopyFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileStorageService_GetStorageQuota_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetStorageQuotaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileStorageServiceServer).GetStorageQuota(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FileStorageService_GetStorageQuota_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileStorageServiceServer).GetStorageQuota(ctx, req.(*GetStorageQuotaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// FileStorageService_ServiceDesc is the grpc.ServiceDesc for FileStorageService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FileStorageService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "configuration.FileStorageService",
	HandlerType: (*FileStorageServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UploadFile",
			Handler:    _FileStorageService_UploadFile_Handler,
		},
		{
			MethodName: "GetFile",
			Handler:    _FileStorageService_GetFile_Handler,
		},
		{
			MethodName: "DeleteFile",
			Handler:    _FileStorageService_DeleteFile_Handler,
		},
		{
			MethodName: "ListFiles",
			Handler:    _FileStorageService_ListFiles_Handler,
		},
		{
			MethodName: "GetUploadUrl",
			Handler:    _FileStorageService_GetUploadUrl_Handler,
		},
		{
			MethodName: "GetDownloadUrl",
			Handler:    _FileStorageService_GetDownloadUrl_Handler,
		},
		{
			MethodName: "MoveFile",
			Handler:    _FileStorageService_MoveFile_Handler,
		},
		{
			MethodName: "CopyFile",
			Handler:    _FileStorageService_CopyFile_Handler,
		},
		{
			MethodName: "GetStorageQuota",
			Handler:    _FileStorageService_GetStorageQuota_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "protos/configuration.proto",
}
